<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perusall Article Downloader</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Console styling */
        #console {
            background-color: #1e1e1e;
            color: #33ff33;
            padding: 10px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            margin-top: 10px;
        }
        #console div {
            margin: 2px 0;
            word-wrap: break-word;
        }
        body {
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        .code-area {
            font-family: monospace;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            white-space: pre;
            overflow-x: auto;
        }

        .progress {
            height: 25px;
        }
        #downloadProgress {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-4">Perusall Article Downloader</h1>
        
        <!-- Instructions -->
        <div class="card mb-4">
            <div class="card-header">
                <h5 class="card-title mb-0">Instructions</h5>
            </div>
            <div class="card-body">
                <ol>
                    <li>Open your Perusall article in Chrome/Firefox</li>
                    <li>Press F12 to open Developer Tools</li>
                    <li>Click on Console tab</li>
                    <li>Copy and paste the code below into the console</li>
                    <li>Wait for the code to finish running (it will scroll through the article)</li>
                    <li>Look for output between "=== START OF DOWNLOAD INFO ===" and "=== END OF DOWNLOAD INFO ==="</li>
                    <li>Copy <strong>everything</strong> including the START and END markers</li>
                    <li>Paste the entire output in the input area below</li>
                </ol>
            </div>
        </div>

        <!-- JavaScript Code -->
        <div class="card mb-4">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="card-title mb-0">JavaScript Code</h5>
                <button class="btn btn-primary btn-sm" onclick="copyCode()">Copy Code</button>
            </div>
            <div class="card-body">
                <div class="code-area" id="codeArea">var len = 0; 
var times = 0;
var i = setInterval(() => { 
    var img = document.querySelectorAll("img.chunk"); 
    img[img.length-1].scrollIntoView(); 
    if (len < img.length) {
        len = img.length;
    } else if (times > 3) {
        var urls = [];
        var pageNums = [];
        img.forEach((e) => {
            urls.push(e.src);
            const pageMatch = e.src.match(/page=(\d+)/);
            if (pageMatch) pageNums.push(parseInt(pageMatch[1]));
        });
        
        // Group images by page number
        const pageMap = {};
        img.forEach((e, idx) => {
            const pageNum = pageNums[idx];
            if (!pageMap[pageNum]) pageMap[pageNum] = [];
            pageMap[pageNum].push(e);
        });
        
        // Sort page numbers
        const sortedPages = Object.keys(pageMap).sort((a,b) => parseInt(a) - parseInt(b));
        
        // Create PDF
        window.jsPDF = window.jspdf.jsPDF;
        const pdf = new jsPDF();
        let isFirstPage = true;
        
        for (const pageNum of sortedPages) {
            const chunks = pageMap[pageNum];
            
            // Create canvas for full page
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate full page dimensions
            let totalHeight = 0;
            let maxWidth = 0;
            for (const img of chunks) {
                totalHeight += img.naturalHeight;
                maxWidth = Math.max(maxWidth, img.naturalWidth);
            }
            
            // Set canvas size
            canvas.width = maxWidth;
            canvas.height = totalHeight;
            
            // Draw chunks in order
            let y = 0;
            for (const img of chunks) {
                ctx.drawImage(img, 0, y);
                y += img.naturalHeight;
            }
            
            // Add to PDF
            if (!isFirstPage) pdf.addPage();
            isFirstPage = false;
            
            const imgData = canvas.toDataURL('image/jpeg', 0.8);
            const imgProps = pdf.getImageProperties(imgData);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
            
            pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
        }
        
        var spl = location.pathname.split('/');
        pdf.save(spl[spl.length-1] + '.pdf');
        
        clearInterval(i);
    } else {
        times++;
    }
}, 2000);

    // Initialize status div
    var status = document.createElement('div');
    status.style.cssText = 'position:fixed;top:10px;right:10px;z-index:9999;padding:10px;background:#000;color:#0f0;border-radius:4px;font-family:monospace;';
    document.body.appendChild(status);

    function log(msg) {
        status.textContent = msg;
        console.log(msg);
    }

    log('Starting...');
    
    // Scroll and collect images
    var len = 0;
    var times = 0;
    var foundImages;
    
    while (times < 10) {
        foundImages = document.querySelectorAll('img.chunk');
        foundImages[foundImages.length-1].scrollIntoView();
        
        if (len === foundImages.length) {
            times++;
        } else {
            len = foundImages.length;
            times = 0;
        }
        
        log('Found ' + len + ' pages...');
        await new Promise(r => setTimeout(r, 1000));
    }

    // Group images by page
    log('Grouping image chunks...');
    const pageChunks = {};
    for (const img of foundImages) {
        // Extract page number from image URL or data-* attribute
        const pageMatch = img.src.match(/page=(\d+)/) || img.getAttribute('data-page');
        if (!pageMatch) continue;
        
        const pageNum = parseInt(pageMatch[1]);
        if (!pageChunks[pageNum]) pageChunks[pageNum] = [];
        pageChunks[pageNum].push(img);
    }

    // Sort pages
    const pageNumbers = Object.keys(pageChunks).sort((a, b) => parseInt(a) - parseInt(b));
    log(`Found ${pageNumbers.length} unique pages`);

    // Create PDF
    log('Creating PDF...');
    window.jsPDF = window.jspdf.jsPDF;
    const pdf = new jsPDF();
    let isFirstPage = true;

    for (const pageNum of pageNumbers) {
        log(`Processing page ${pageNum}`);
        const chunks = pageChunks[pageNum];
        
        // Create canvas for full page
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Calculate full page dimensions
        let totalHeight = 0;
        let maxWidth = 0;
        for (const img of chunks) {
            totalHeight += img.naturalHeight;
            maxWidth = Math.max(maxWidth, img.naturalWidth);
        }
        
        // Set canvas size
        canvas.width = maxWidth;
        canvas.height = totalHeight;
        
        // Draw chunks in order
        let y = 0;
        for (const img of chunks) {
            ctx.drawImage(img, 0, y);
            y += img.naturalHeight;
        }
        
        // Add to PDF
        if (!isFirstPage) pdf.addPage();
        isFirstPage = false;
        
        const imgData = canvas.toDataURL('image/jpeg', 0.8);
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
        
        pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
    }

    // Save PDF
    log('Saving PDF...');
    const name = location.pathname.split('/').pop();
    pdf.save(name + '.pdf');
    log('Done!');
})();</div>
            </div>
        </div>

        <!-- Input Area -->
        <div class="card mb-4">
            <div class="card-header">
                <h5 class="card-title mb-0">Download Info</h5>
            </div>
            <div class="card-body">
                <textarea id="inputArea" class="form-control mb-3" rows="8" placeholder="Paste the download info here..."></textarea>
                <button class="btn btn-primary" onclick="downloadArticle()">Download Article</button>
                
                <!-- Progress Section -->
                <div id="downloadProgress" class="mt-3">
                    <div class="progress mb-2">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                    <div id="progressText" class="text-muted">Preparing download...</div>
                </div>
            </div>
        </div>

        <!-- Console Output -->
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">Console</h5>
            </div>
            <div class="card-body">
                <div id="console"></div>
            </div>
        </div>
    </div>

    <script>
        // Copy button functionality
        async function copyCode() {
            try {
                const codeArea = document.getElementById('codeArea');
                if (!codeArea) {
                    alert('Error: Code area not found!');
                    return;
                }
                
                await navigator.clipboard.writeText(codeArea.textContent);
                
                // Visual feedback
                const btn = document.querySelector('button.btn-primary');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = originalText, 2000);
            } catch (err) {
                console.error('Copy failed:', err);
                alert('Failed to copy code. Please try selecting and copying manually.');
            }
        }
        // Initialize jsPDF
        window.jsPDF = window.jspdf.jsPDF;
        // Register service worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(registration => {
                    console.log('Service Worker registered');
                })
                .catch(error => {
                    console.error('Service Worker registration failed:', error);
                });
        }

        function copyCode() {
            const codeArea = document.getElementById('codeArea');
            const text = codeArea.textContent;
            
            // Create temporary textarea
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            
            // Select and copy
            textarea.select();
            let success = false;
            try {
                success = document.execCommand('copy');
            } catch (err) {
                console.error('Failed to copy:', err);
            }
            
            // Clean up
            document.body.removeChild(textarea);
            
            // Update button text
            const btn = document.querySelector('.btn-primary');
            btn.textContent = success ? 'Copied!' : 'Failed to copy';
            setTimeout(() => btn.textContent = 'Copy Code', 2000);
        }

        function logMessage(message) {
            const consoleDiv = document.getElementById('console');
            if (!consoleDiv) {
                window.console.error('Console div not found!');
                return;
            }
            consoleDiv.innerHTML += `<div>${message}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            // Also log to browser console
            window.console.log(message);
        }

        function updateProgress(percent, message) {
            document.getElementById('downloadProgress').style.display = 'block';
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressText').textContent = message;
        }

        async function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Cache for downloaded chunks
        let chunkCache = new Map();

        async function tryFetchWithDataUrl(url) {
            try {
                // Create a temporary link to open in new tab
                const tempLink = document.createElement('a');
                tempLink.href = url;
                tempLink.target = '_blank';
                
                // Show instructions to user
                logMessage('Direct download required for this chunk. Please:');
                logMessage('1. Click OK when ready to open the image in a new tab');
                logMessage('2. Right-click the image and select "Copy Image"');
                logMessage('3. Return to this tab and paste the image when prompted');
                
                await new Promise(resolve => {
                    if (confirm('Click OK to open the image in a new tab. After copying the image, return to this tab.')) {
                        resolve();
                    }
                });
                
                // Open URL in new tab
                tempLink.click();
                
                // Create paste area
                const pasteArea = document.createElement('div');
                pasteArea.contentEditable = true;
                pasteArea.style.position = 'fixed';
                pasteArea.style.top = '50%';
                pasteArea.style.left = '50%';
                pasteArea.style.transform = 'translate(-50%, -50%)';
                pasteArea.style.width = '300px';
                pasteArea.style.height = '100px';
                pasteArea.style.border = '2px dashed #007bff';
                pasteArea.style.padding = '10px';
                pasteArea.style.backgroundColor = 'white';
                pasteArea.style.zIndex = '1000';
                pasteArea.innerHTML = 'Paste image here (Ctrl+V or Cmd+V)';
                
                document.body.appendChild(pasteArea);
                pasteArea.focus();
                
                // Wait for paste
                const dataUrl = await new Promise((resolve, reject) => {
                    let timeoutId = setTimeout(() => {
                        document.body.removeChild(pasteArea);
                        reject(new Error('Paste timeout'));
                    }, 60000);
                    
                    pasteArea.addEventListener('paste', async (e) => {
                        e.preventDefault();
                        const items = (e.clipboardData || window.clipboardData).items;
                        let blob = null;
                        
                        for (const item of items) {
                            if (item.type.indexOf('image') !== -1) {
                                blob = item.getAsFile();
                                break;
                            }
                        }
                        
                        if (blob) {
                            clearTimeout(timeoutId);
                            document.body.removeChild(pasteArea);
                            
                            // Convert blob to data URL
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = () => reject(new Error('Failed to read pasted image'));
                            reader.readAsDataURL(blob);
                        } else {
                            reject(new Error('No image found in clipboard'));
                        }
                    });
                });
                
                return dataUrl;
            } catch (error) {
                throw new Error(`Data URL fallback failed: ${error.message}`);
            }
        }

        async function getProxyUrl(url, proxyIndex = 0) {
            const proxies = [
                (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
                (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
                (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
                (url) => `https://cors-proxy.htmldriven.com/?url=${encodeURIComponent(url)}`,
                (url) => `https://cors.bridged.cc/${url}`,
                (url) => `https://proxy.cors.sh/${url}`,
                (url) => `https://cors.eu.org/${url}`,
                (url) => `https://yacdn.org/proxy/${url}`
            ];
            return proxies[proxyIndex % proxies.length](url);
        }

        async function downloadChunk(url, index, blobUrls) {
            // Check cache first
            if (chunkCache.has(url)) {
                logMessage(`Using cached version of chunk ${index + 1}`);
                return chunkCache.get(url);
            }

            // Try each proxy in sequence
            let proxyIndex = 0;
            let lastError = null;

            while (proxyIndex < 8) { // Try all proxies
                if (proxyIndex > 0) {
                    const delay = 1000;
                    logMessage(`Trying different proxy for chunk ${index + 1} (proxy ${proxyIndex + 1}/8)...`);
                    await sleep(delay);
                }

                try {
                    const proxyUrl = await getProxyUrl(url, proxyIndex);
                    const response = await fetch(proxyUrl, {
                        headers: {
                            'x-requested-with': 'XMLHttpRequest'
                        }
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const blob = await response.blob();
                    if (blob.size === 0) {
                        throw new Error('Empty response');
                    }

                    const imgUrl = URL.createObjectURL(blob);
                    blobUrls.push(imgUrl);
                    chunkCache.set(url, imgUrl);
                    logMessage(`Downloaded and cached chunk ${index + 1}`);
                    return imgUrl;
                } catch (error) {
                    lastError = error;
                }
            }

                proxyIndex++;
            }

            throw new Error(`Failed to download chunk ${index + 1}: All proxies failed`);
        }

        async function downloadChunksInParallel(urls, blobUrls, startPage = 1) {
            // Adjust URLs to start from specified page
            if (startPage > 1) {
                urls = urls.slice(startPage - 1);
            }
            const BATCH_SIZE = 1; // Process one at a time for manual downloads
            const images = new Array(urls.length).fill(null);
            const failedChunks = [];
            let consecutiveFailures = 0;

            // Process URLs in batches
            for (let i = 0; i < urls.length; i += BATCH_SIZE) {
                const batchEnd = Math.min(i + BATCH_SIZE, urls.length);
                const batchPromises = [];

                // Create batch of promises
                for (let j = i; j < batchEnd; j++) {
                    batchPromises.push(
                        downloadChunk(urls[j], j, blobUrls)
                            .then(imgUrl => {
                                images[j] = imgUrl;
                                consecutiveFailures = 0; // Reset on success
                                updateProgress((j / urls.length) * 60, `Downloaded ${j + 1} of ${urls.length} chunks`);
                            })
                            .catch(error => {
                                logMessage(`Error downloading chunk ${j + 1}: ${error.message}`);
                                failedChunks.push(j + 1);
                                consecutiveFailures++;
                            })
                    );
                }

                await Promise.all(batchPromises);
                
                if (batchEnd < urls.length) {
                    await sleep(1000); // Small delay between chunks
                }
            }

            if (failedChunks.length > 0) {
                // Show all pages in a grid for easy downloading
                const failedDiv = document.createElement('div');
                failedDiv.className = 'mt-3';
                failedDiv.innerHTML = `
                    <div class="alert alert-warning">
                        <h5>Some pages failed to download automatically</h5>
                        <p>1. Click each failed page below to open it in a new tab</p>
                        <p>2. Save all images (right-click → Save Image As...)</p>
                        <p>3. Use a PDF tool to combine them with the main PDF</p>
                    </div>
                    <div class="row">
                        ${failedChunks.map(pageNum => `
                            <div class="col-md-4 mb-2">
                                <div class="card">
                                    <div class="card-body text-center">
                                        <h5 class="card-title">Page ${pageNum}</h5>
                                        <a href="${urls[pageNum - 1]}" target="_blank" class="btn btn-primary">Open Page ${pageNum}</a>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                document.getElementById('status').appendChild(failedDiv);
                throw new Error(`Failed to download chunks: ${failedChunks.join(', ')}`);
            }

            return images;
        }

        async function combineImageChunks(images) {
            const CHUNKS_PER_PAGE = 6;
            const pages = [];
            for (let i = 0; i < images.length; i += CHUNKS_PER_PAGE) {
                pages.push(images.slice(i, i + CHUNKS_PER_PAGE));
            }
            
            logMessage(`Starting to combine ${images.length} chunks...`);
            logMessage(`Grouped into ${pages.length} pages`);
            
            const combinedPages = [];
            const failedPages = [];
            
            for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                const pageChunks = pages[pageIndex];
                logMessage(`Processing page ${pageIndex + 1} with ${pageChunks.length} chunks`);
                
                const MAX_PAGE_RETRIES = 3;
                let success = false;
                let lastError = null;
                
                for (let pageAttempt = 1; pageAttempt <= MAX_PAGE_RETRIES && !success; pageAttempt++) {
                    try {
                        // Load all images for this page with individual retries
                        const loadedImages = [];
                        for (const chunk of pageChunks) {
                            if (!chunk) {
                                throw new Error('Missing chunk in page');
                            }
                            const img = await loadImageWithRetry(chunk, 3);
                            loadedImages.push(img);
                        }
                        
                        logMessage(`Loaded ${loadedImages.length} images for page ${pageIndex + 1}`);
                        
                        // Log dimensions of each chunk
                        loadedImages.forEach((img, idx) => {
                            logMessage(`Chunk ${idx + 1}: ${img.width}x${img.height}`);
                        });
                        
                        // Create canvas with proper dimensions
                        const canvas = document.createElement('canvas');
                        const firstImage = loadedImages[0];
                        canvas.width = firstImage.width;
                        canvas.height = loadedImages.reduce((total, img) => total + img.height, 0);
                        
                        logMessage(`Canvas size: ${canvas.width}x${canvas.height}`);
                        
                        // Draw images onto canvas
                        const ctx = canvas.getContext('2d');
                        let y = 0;
                        
                        for (const img of loadedImages) {
                            ctx.drawImage(img, 0, y);
                            y += img.height;
                        }
                        
                        // Convert to blob with progressive quality reduction if needed
                        let quality = 0.95;
                        let blob;
                        
                        while (quality >= 0.5) {
                            try {
                                blob = await new Promise(resolve => {
                                    canvas.toBlob(resolve, 'image/jpeg', quality);
                                });
                                
                                if (blob.size <= 5000000 || quality <= 0.5) {
                                    break;
                                }
                                
                                quality -= 0.1;
                                logMessage(`Reducing quality to ${quality.toFixed(2)} for page ${pageIndex + 1}`);
                            } catch (error) {
                                logMessage(`Error creating blob: ${error.message}`);
                                throw error;
                            }
                        }
                        
                        const combinedUrl = URL.createObjectURL(blob);
                        combinedPages.push({ url: combinedUrl, pageNum: pageIndex + 1 });
                        logMessage(`Successfully combined page ${pageIndex + 1}`);
                        success = true;
                        
                    } catch (error) {
                        lastError = error;
                        logMessage(`Error processing page ${pageIndex + 1} (attempt ${pageAttempt}): ${error.message}`);
                        
                        if (pageAttempt < MAX_PAGE_RETRIES) {
                            logMessage(`Retrying entire page ${pageIndex + 1} (attempt ${pageAttempt + 1}/${MAX_PAGE_RETRIES})`);
                            await sleep(pageAttempt * 2000);
                        }
                    }
                }
                
                if (!success) {
                    failedPages.push(pageIndex + 1);
                    logMessage(`Failed to process page ${pageIndex + 1} after all attempts`);
                }
            }
            
            if (failedPages.length > 0) {
                logMessage(`Warning: Failed to process ${failedPages.length} pages: ${failedPages.join(', ')}`);
                if (combinedPages.length === 0) {
                    throw new Error('Failed to process any pages successfully');
                }
            }
            
            return { combinedPages, failedPages };
        }

        async function createPDFWithRetry(pagesData, title) {
            const { combinedPages, failedPages } = pagesData;
            const MAX_RETRIES = 3;
            let lastError = null;

            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    const { jsPDF } = window.jspdf;
                    if (!jsPDF) {
                        throw new Error('PDF library not loaded. Please refresh the page and try again.');
                    }

                    const doc = new jsPDF();
                    
                    for (let i = 0; i < combinedPages.length; i++) {
                        const { url, pageNum } = combinedPages[i];
                        updateProgress(90 + (i / combinedPages.length) * 10, `Adding page ${pageNum} to PDF...`);
                        
                        if (i > 0) doc.addPage();
                        
                        const img = await loadImageWithRetry(url, 2);

                        // Calculate dimensions to fit page
                        const pageWidth = doc.internal.pageSize.getWidth();
                        const pageHeight = doc.internal.pageSize.getHeight();
                        const imgRatio = img.width / img.height;
                        const pageRatio = pageWidth / pageHeight;
                        
                        let width = pageWidth;
                        let height = width / imgRatio;
                        
                        if (height > pageHeight) {
                            height = pageHeight;
                            width = height * imgRatio;
                        }
                        
                        const x = (pageWidth - width) / 2;
                        const y = (pageHeight - height) / 2;
                        
                        doc.addImage(img, 'JPEG', x, y, width, height);
                        logMessage(`Added page ${pageNum} to PDF`);
                    }

                    // Create download buttons
                    const container = document.createElement('div');
                    container.className = 'mt-3';
                    
                    const downloadBtn = document.createElement('button');
                    downloadBtn.className = 'btn btn-success';
                    downloadBtn.textContent = `Download PDF (${combinedPages.length} pages)`;
                    if (failedPages.length > 0) {
                        downloadBtn.textContent += ` - Missing pages: ${failedPages.join(', ')}`;
                    }
                    downloadBtn.onclick = () => {
                        try {
                            const filename = failedPages.length > 0 ? 
                                `${title}_partial.pdf` : 
                                `${title}.pdf`;
                            doc.save(filename);
                            logMessage('PDF downloaded successfully!');
                        } catch (error) {
                            logMessage('Error saving PDF: ' + error.message);
                        }
                    };
                    container.appendChild(downloadBtn);
                    
                    // Add manual download button for failed pages
                    if (failedPages.length > 0) {
                        const manualBtn = document.createElement('button');
                        manualBtn.className = 'btn btn-warning ml-2';
                        manualBtn.textContent = `Download Failed Pages (${failedPages.length})`;
                        manualBtn.onclick = () => {
                            const urls = input.match(/urls = '''([\s\S]*?)'''/)[1].trim().split('\n');
                            failedPages.forEach(pageNum => {
                                const startIndex = (pageNum - 1) * 6;
                                const pageUrls = urls.slice(startIndex, startIndex + 6);
                                pageUrls.forEach(url => window.open(url, '_blank'));
                            });
                            logMessage('Manual download: Failed pages opened in new tabs');
                            logMessage('1. Save each image (right-click -> Save Image As...)');
                            logMessage('2. Use a PDF tool to combine the images');
                        };
                        container.appendChild(manualBtn);
                    }
                    
                    document.querySelector('.card-body').appendChild(container);
                    updateProgress(100, failedPages.length > 0 ? 'Partial PDF created!' : 'PDF creation complete!');
                    
                    return true;
                } catch (error) {
                    lastError = error;
                    logMessage(`PDF creation attempt ${attempt + 1} failed: ${error.message}`);
                    if (attempt < MAX_RETRIES - 1) {
                        const waitTime = 2000 * (attempt + 1);
                        logMessage(`Retrying PDF creation in ${waitTime/1000} seconds...`);
                        await sleep(waitTime);
                    }
                }
            }
            
            throw new Error(`Failed to create PDF after ${MAX_RETRIES} attempts: ${lastError.message}`);
        }

        async function downloadArticle() {
            console.log('Download started...'); // Browser console log
            
            // Clear previous console output
            const consoleDiv = document.getElementById('console');
            if (consoleDiv) {
                consoleDiv.innerHTML = '';
            }
            
            logMessage('Starting download process...');
            logMessage('Checking PDF library initialization...');
            
            // Add error handler
            window.onerror = function(message, source, lineno, colno, error) {
                logMessage(`Error: ${message}`);
                return false;
            };
            const inputArea = document.getElementById('inputArea');
            if (!inputArea) {
                logMessage('ERROR: Input area not found!');
                return;
            }
            
            const input = inputArea.value;
            logMessage('Got input: ' + (input ? input.length + ' characters' : 'empty'));
            
            if (!input) {
                logMessage('ERROR: No input provided');
                alert('Please paste the download info first!');
                return;
            }

            // Disable the download button and input area
            const downloadBtn = document.getElementById('downloadBtn');
            const inputArea = document.getElementById('inputArea');
            if (downloadBtn) downloadBtn.disabled = true;
            if (inputArea) inputArea.disabled = true;

            const blobUrls = []; // Keep track of blob URLs
            try {
                // Show starting status
                updateProgress(0, 'Starting download...');
                document.getElementById('downloadProgress').style.display = 'block';
                
                logMessage('Parsing input...');
                
                // Check for markers
                if (!input.includes('=== START OF DOWNLOAD INFO ===')) {
                    throw new Error('Missing start marker. Make sure to copy the ENTIRE output!');
                }
                if (!input.includes('=== END OF DOWNLOAD INFO ===')) {
                    throw new Error('Missing end marker. Make sure to copy the ENTIRE output!');
                }
                
                // Parse input
                const urlsMatch = input.match(/urls = '''([\s\S]*?)'''/);
                const titleMatch = input.match(/title="([^"]*)"/);
                
                if (!urlsMatch) {
                    throw new Error('Could not find URLs in the pasted text. Make sure to copy the ENTIRE output including the === START === and === END === markers.');
                }
                
                if (!titleMatch) {
                    throw new Error('Could not find document title in the pasted text. Make sure to copy the ENTIRE output including the === START === and === END === markers.');
                }

                // Validate URLs
                const urls = urlsMatch[1].trim().split('\n').filter(url => url.trim());
                if (urls.length === 0) {
                    throw new Error('No valid URLs found in the input.');
                }

                const title = titleMatch[1];
                
                logMessage(`Found ${urls.length} pages to download`);
                logMessage(`Document title: ${title}`);
                
                if (!window.jsPDF) {
                    throw new Error('PDF library not initialized. Please refresh the page and try again.');
                }

                // Initialize jsPDF again just in case
                try {
                    new window.jsPDF();
                } catch (error) {
                    throw new Error('PDF library failed to initialize: ' + error.message);
                }
                
                logMessage('PDF library initialized successfully');
                logMessage(`Downloading ${urls.length} chunks in parallel batches...`);

                // Download chunks in parallel batches
                const images = await downloadChunksInParallel(urls, blobUrls);

                updateProgress(70, 'Combining image chunks into pages...');
                logMessage('All chunks downloaded. Combining into full pages...');

                // Combine chunks into full pages
                const pagesData = await combineImageChunks(images);
                
                updateProgress(90, 'Creating PDF...');
                logMessage(`Creating PDF with ${pagesData.combinedPages.length} pages...`);

                // Create PDF with retry
                await createPDFWithRetry(pagesData, title);

            } catch (error) {
                logMessage('Error: ' + error.message);
                updateProgress(0, 'Error: ' + error.message);
                
                // Show manual download button for all pages
                const manualBtn = document.createElement('button');
                manualBtn.className = 'btn btn-warning mt-3';
                manualBtn.textContent = 'Try Manual Download';
                manualBtn.onclick = () => {
                    const urls = input.match(/urls = '''([\s\S]*?)'''/)[1].trim().split('\n');
                    urls.forEach((url, index) => {
                        window.open(url, '_blank');
                    });
                    logMessage('Manual download: All pages opened in new tabs');
                    logMessage('1. Save each image (right-click -> Save Image As...)');
                    logMessage('2. Use a PDF tool to combine the images');
                };
                document.querySelector('.card-body').appendChild(manualBtn);
            } finally {
                // Clean up blob URLs
                blobUrls.forEach(URL.revokeObjectURL);
                
                // Re-enable the download button and input area
                if (downloadBtn) downloadBtn.disabled = false;
                if (inputArea) inputArea.disabled = false;
            }
        }
    </script>
</body>
</html>
